/* automatically generated by JSCoverage - do not edit */
if (typeof _$jscoverage === 'undefined') _$jscoverage = {};
if (! _$jscoverage['short-memory.min.js']) {
  _$jscoverage['short-memory.min.js'] = [];
  _$jscoverage['short-memory.min.js'][2] = 0;
}
_$jscoverage['short-memory.min.js'][2]++;
(function () {
  _$jscoverage['short-memory.min.js'][2]++;
  var e, t, n = ({}).hasOwnProperty, o = (function (e, t) {
  _$jscoverage['short-memory.min.js'][2]++;
  function o() {
    _$jscoverage['short-memory.min.js'][2]++;
    this.constructor = e;
}
  _$jscoverage['short-memory.min.js'][2]++;
  for (var r in t) {
    _$jscoverage['short-memory.min.js'][2]++;
    n.call(t, r) && (e[r] = t[r]);
}
  _$jscoverage['short-memory.min.js'][2]++;
  return o.prototype = t.prototype, e.prototype = new o(), e.__super__ = t.prototype, e;
});
  _$jscoverage['short-memory.min.js'][2]++;
  t = (function (t) {
  _$jscoverage['short-memory.min.js'][2]++;
  function n(e) {
    _$jscoverage['short-memory.min.js'][2]++;
    var t, o, a, i, u, l;
    _$jscoverage['short-memory.min.js'][2]++;
    if (r = this, null == e && (e = {}), null == (t = e.maxSize) && (e.maxSize = 0), null == (o = e.maxCount) && (e.maxCount = 0), null == (a = e.maxAge) && (e.maxAge = 0), null == (i = e.deathTime) && (e.deathTime = 0), null == (u = e.pruneTime) && (e.pruneTime = 5), null == (l = e.debug) && (e.debug = false), r.maxSize = e.maxSize, r.maxCount = e.maxCount, r.maxAge = e.maxAge, r.debug = e.debug, r.pruneTime = e.pruneTime, r.deathTime = e.deathTime, r.deathTime > r.maxAge) {
      _$jscoverage['short-memory.min.js'][2]++;
      throw "deathTime of cache cannot be greater than maxAge";
    }
    _$jscoverage['short-memory.min.js'][2]++;
    (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  return n.prototype.prune.call(e);
})(r);
}
  _$jscoverage['short-memory.min.js'][2]++;
  var r;
  _$jscoverage['short-memory.min.js'][2]++;
  return o(n, t), n.prototype.heap = {}, n.prototype.maxSize = 0, n.prototype.maxCount = 0, n.prototype.maxAge = 0, n.prototype.pruneTime = 5, n.prototype.deathTime = 0, n.prototype.debug = false, r = n, n.prototype.set = (function (e, t, n, o) {
  _$jscoverage['short-memory.min.js'][2]++;
  return "function" == typeof n && (o = n, n = {}), "function" == typeof o? (r.debug && console.log("Debug: set has a callback; running async"), process.nextTick((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  var a;
  _$jscoverage['short-memory.min.js'][2]++;
  return a = r.setInternal(e, t, n), o(a[0], a[1]);
})), null): (r.debug && console.log("Debug: get has no callback; running sync"), r.setInternal(e, t, n)[1]);
}), n.prototype.setInternal = (function (t, n, o) {
  _$jscoverage['short-memory.min.js'][2]++;
  var a, i, u;
  _$jscoverage['short-memory.min.js'][2]++;
  try {
    _$jscoverage['short-memory.min.js'][2]++;
    return null == o && (o = {}), null == (i = o.maxAge) && (o.maxAge = r.maxAge), null == (u = o.deathTime) && (o.deathTime = r.deathTime), a = new e(t, n, o), r.heap[t] = a, r.debug && console.log("Debug: set heap[" + t + "] to " + n), [null, a.data];
  }
  catch (l) {
    _$jscoverage['short-memory.min.js'][2]++;
    return console.error("Unable to set memorable: " + l), [{type: "exception", message: l}, null];
  }
}), n.prototype.get = (function (e, t) {
  _$jscoverage['short-memory.min.js'][2]++;
  return r = this, "function" == typeof t? (r.debug && console.log("Debug: get has a callback; running async"), process.nextTick((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  var n;
  _$jscoverage['short-memory.min.js'][2]++;
  return n = r.getInternal(e), t(n[0], n[1]);
})), null): (r.debug && console.log("Debug: get has no callback; running sync"), r.getInternal(e)[1]);
}), n.prototype.getInternal = (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  var t;
  _$jscoverage['short-memory.min.js'][2]++;
  return r.debug && console.log("Debug: getting key " + e + " from heap"), t = r.heap[e], t === void 0? (r.debug && console.log("Debug: not found"), [{type: "notfound", message: "Key " + e + " not found in heap."}, null]): t.isGood? (r.debug && console.log("Debug: found it!"), [null, t.data]): (r.debug && console.log("Debug: expired or invalid"), r.destroy(e), [{type: "notvalid", message: "Key " + e + " expired or invalid."}, null]);
}), n.prototype.getOrSet = (function (e, t, n, o) {
  _$jscoverage['short-memory.min.js'][2]++;
  var a;
  _$jscoverage['short-memory.min.js'][2]++;
  if (r = this, "function" == typeof n && (o = n, n = {}), "function" != typeof o) {
    _$jscoverage['short-memory.min.js'][2]++;
    if (r.debug && console.log("Debug: getOrSet; getting sync"), a = r.getInternal(e), a[0]) {
      _$jscoverage['short-memory.min.js'][2]++;
      if (r.debug && console.log("Debug: getOrSet; no valid key; setting"), n.async) {
        _$jscoverage['short-memory.min.js'][2]++;
        throw "Cannot call getOrSet async without a callback!";
      }
      _$jscoverage['short-memory.min.js'][2]++;
      return r.setInternal(e, t(), n);
    }
    _$jscoverage['short-memory.min.js'][2]++;
    if (r.heap[e].isNearDeath()) {
      _$jscoverage['short-memory.min.js'][2]++;
      if (r.debug && console.log("Debug: getOrSet; key is near death; will set after get"), n.async) {
        _$jscoverage['short-memory.min.js'][2]++;
        throw "Cannot call getOrSet async without a callback!";
      }
      _$jscoverage['short-memory.min.js'][2]++;
      process.nextTick((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return r.set(e, t(e, n));
}));
    }
    _$jscoverage['short-memory.min.js'][2]++;
    return a[1];
  }
  _$jscoverage['short-memory.min.js'][2]++;
  return r.debug && console.log("Debug: getOrSet; getting async"), r.get(e, (function (a, i) {
  _$jscoverage['short-memory.min.js'][2]++;
  return a? (r.debug && console.log("Debug: getOrSet; key invalid, setting back"), n.async? (r.debug && console.log("Debug: getOrSet; setback is async"), t(e, (function (t) {
  _$jscoverage['short-memory.min.js'][2]++;
  return r.set(e, t, n, o);
}))): (r.debug && console.log("Debug: getOrSet; setback is sync"), r.set(e, t(e), n, o))): (r.debug && console.log("Debug: getOrSet; key exists, calling back"), o(null, i), r.heap[e].isNearDeath()? (r.debug && console.log("Debug: getOrSet; key is near death; will set after get"), n.async? process.nextTick((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return t(e, (function (t) {
  _$jscoverage['short-memory.min.js'][2]++;
  return r.set(e, t, n);
}));
})): process.nextTick((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return r.set(e, t(e, n));
}))): void 0);
})), r.get(e, (function (a, i) {
  _$jscoverage['short-memory.min.js'][2]++;
  var u;
  _$jscoverage['short-memory.min.js'][2]++;
  return a? "notfound" === a.type || "invalid" === a.type? (u = t(), r.set(e, u, n, o)): o(a): o(null, i);
}));
}), n.prototype.destroy = (function (e, t) {
  _$jscoverage['short-memory.min.js'][2]++;
  return "function" == typeof t? process.nextTick((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return r.heap[e] === void 0? (r.debug && console.log("Debug: destroy async - key does not exist: " + e), t(false)): (r.debug && console.log("Debug: destroy async - destroying key: " + e), r.heap[e].destroy(), t(delete r.heap[e]));
})): r.heap[e] === void 0? (r.debug && console.log("Debug: destroy sync - key does not exist: " + e), false): (r.debug && console.log("Debug: destroy sync - destroying key: " + e), r.heap[e].emit("destroy"), delete r.heap[e]);
}), n.prototype.prune = (function () {
  _$jscoverage['short-memory.min.js'][2]++;
  var e, t, o, a, i, u, l, s, c, g, p, d, y, f, m, h;
  _$jscoverage['short-memory.min.js'][2]++;
  r.emit("pre-prune"), clearTimeout(r.timer), u = [], l = 0, m = r.heap;
  _$jscoverage['short-memory.min.js'][2]++;
  for (t in m) {
    _$jscoverage['short-memory.min.js'][2]++;
    o = m[t], o.isGood() || u.push(t);
}
  _$jscoverage['short-memory.min.js'][2]++;
  for (c = 0, d = u.length; d > c; c++) {
    _$jscoverage['short-memory.min.js'][2]++;
    t = u[c], l++, r.destroy(t);
}
  _$jscoverage['short-memory.min.js'][2]++;
  if (0 !== r.maxCount && (e = Object.keys(r.heap).length, e > r.maxCount)) {
    _$jscoverage['short-memory.min.js'][2]++;
    for (a = e - r.maxCount, u = Object.keys(r.heap).slice(0, a), g = 0, y = u.length; y > g; g++) {
      _$jscoverage['short-memory.min.js'][2]++;
      t = u[g], l++, r.destroy(t);
}
  }
  _$jscoverage['short-memory.min.js'][2]++;
  if (0 !== r.maxSize && (s = r.calculateSize(), s > r.maxSize)) {
    _$jscoverage['short-memory.min.js'][2]++;
    i = s - r.maxSize, u = [], h = r.heap;
    _$jscoverage['short-memory.min.js'][2]++;
    for (t in h) {
      _$jscoverage['short-memory.min.js'][2]++;
      if (o = h[t], u.push(t), i -= o.size, 0 >= i) {
        _$jscoverage['short-memory.min.js'][2]++;
        break;
      }
}
    _$jscoverage['short-memory.min.js'][2]++;
    for (p = 0, f = u.length; f > p; p++) {
      _$jscoverage['short-memory.min.js'][2]++;
      t = u[p], l++, r.destroy(t);
}
  }
  _$jscoverage['short-memory.min.js'][2]++;
  return r.timer = setTimeout((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return n.prototype.prune.call(r);
}), 1000 * r.pruneTime), r.emit("prune"), l;
}), n.prototype.calculateSize = (function () {
  _$jscoverage['short-memory.min.js'][2]++;
  var e, t, n, o;
  _$jscoverage['short-memory.min.js'][2]++;
  n = 0, o = r.heap;
  _$jscoverage['short-memory.min.js'][2]++;
  for (e in o) {
    _$jscoverage['short-memory.min.js'][2]++;
    t = o[e], n += t.size;
}
  _$jscoverage['short-memory.min.js'][2]++;
  return n;
}), n.prototype.isHealthy = (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  var t;
  _$jscoverage['short-memory.min.js'][2]++;
  return t = r.heap[e], t? t.isGood() && ! t.isNearDeath(): false;
}), n;
})(require("events").EventEmitter), e = (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  function t(e, t, o) {
    _$jscoverage['short-memory.min.js'][2]++;
    var r, a;
    _$jscoverage['short-memory.min.js'][2]++;
    if (n = this, e === void 0) {
      _$jscoverage['short-memory.min.js'][2]++;
      throw "Memorable missing key element";
    }
    _$jscoverage['short-memory.min.js'][2]++;
    if (t === void 0) {
      _$jscoverage['short-memory.min.js'][2]++;
      throw "Memorable missing data element";
    }
    _$jscoverage['short-memory.min.js'][2]++;
    null == o && (o = {}), null == (r = o.maxAge) && (o.maxAge = 0), null == (a = o.deathTime) && (o.deathTime = 0), n.key = e, n.data = t, 0 !== o.maxAge && (n.expires = Date.now() + 1000 * o.maxAge), n.deathTime = o.deathTime, n.size = n.calculateSize();
}
  _$jscoverage['short-memory.min.js'][2]++;
  var n;
  _$jscoverage['short-memory.min.js'][2]++;
  return o(t, e), t.prototype.key = "", t.prototype.data = {}, t.prototype.invalid = false, t.prototype.size = 0, t.prototype.expires = 0, t.prototype.deathTime = 0, n = t, t.prototype.isGood = (function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return 0 !== n.expires && Date.now() > n.expires && n.invalidate(), ! n.invalid;
}), t.prototype.isNearDeath = (function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return Date.now() > n.expires - 1000 * n.deathTime;
}), t.prototype.invalidate = (function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return n.invalid = true, n.emit("invalidate");
}), t.prototype.calculateSize = (function () {
  _$jscoverage['short-memory.min.js'][2]++;
  var e, t, o, r, a, i, u, l;
  _$jscoverage['short-memory.min.js'][2]++;
  for (o = [], i = [n.data], e = 0, r = null, a = (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  return e.__c || false;
}), t = (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  return e.__c = true;
}), u = (function (e) {
  _$jscoverage['short-memory.min.js'][2]++;
  return delete e.__c;
}); i.length;) {
    _$jscoverage['short-memory.min.js'][2]++;
    l = i.pop(), (function (n) {
  _$jscoverage['short-memory.min.js'][2]++;
  var r, l;
  _$jscoverage['short-memory.min.js'][2]++;
  if ("string" == typeof n) {
    _$jscoverage['short-memory.min.js'][2]++;
    return e += 2 * n.length;
  }
  _$jscoverage['short-memory.min.js'][2]++;
  if ("boolean" == typeof n) {
    _$jscoverage['short-memory.min.js'][2]++;
    return e += 4;
  }
  _$jscoverage['short-memory.min.js'][2]++;
  if ("number" == typeof n) {
    _$jscoverage['short-memory.min.js'][2]++;
    return e += 8;
  }
  _$jscoverage['short-memory.min.js'][2]++;
  if ("object" == typeof n && ! a(n)) {
    _$jscoverage['short-memory.min.js'][2]++;
    o.push((function () {
  _$jscoverage['short-memory.min.js'][2]++;
  return u(n);
}));
    _$jscoverage['short-memory.min.js'][2]++;
    for (r in n) {
      _$jscoverage['short-memory.min.js'][2]++;
      l = n[r], n.hasOwnProperty(r) && i.push(l);
}
    _$jscoverage['short-memory.min.js'][2]++;
    return t(n);
  }
})(l);
}
  _$jscoverage['short-memory.min.js'][2]++;
  for (; r = o.pop();) {
    _$jscoverage['short-memory.min.js'][2]++;
    r.call();
}
  _$jscoverage['short-memory.min.js'][2]++;
  return e;
}), t;
})(require("events").EventEmitter), module.exports = t;
}).call(this);
_$jscoverage['short-memory.min.js'].source = ["/* short-memory; Copyright 2012 Aejay Goehring. Licensed under MIT License; See LICENSE for details. */","(function(){var e,t,n={}.hasOwnProperty,o=function(e,t){function o(){this.constructor=e}for(var r in t)n.call(t,r)&amp;&amp;(e[r]=t[r]);return o.prototype=t.prototype,e.prototype=new o,e.__super__=t.prototype,e};t=function(t){function n(e){var t,o,a,i,u,l;if(r=this,null==e&amp;&amp;(e={}),null==(t=e.maxSize)&amp;&amp;(e.maxSize=0),null==(o=e.maxCount)&amp;&amp;(e.maxCount=0),null==(a=e.maxAge)&amp;&amp;(e.maxAge=0),null==(i=e.deathTime)&amp;&amp;(e.deathTime=0),null==(u=e.pruneTime)&amp;&amp;(e.pruneTime=5),null==(l=e.debug)&amp;&amp;(e.debug=!1),r.maxSize=e.maxSize,r.maxCount=e.maxCount,r.maxAge=e.maxAge,r.debug=e.debug,r.pruneTime=e.pruneTime,r.deathTime=e.deathTime,r.deathTime&gt;r.maxAge)throw\"deathTime of cache cannot be greater than maxAge\";(function(e){return n.prototype.prune.call(e)})(r)}var r;return o(n,t),n.prototype.heap={},n.prototype.maxSize=0,n.prototype.maxCount=0,n.prototype.maxAge=0,n.prototype.pruneTime=5,n.prototype.deathTime=0,n.prototype.debug=!1,r=n,n.prototype.set=function(e,t,n,o){return\"function\"==typeof n&amp;&amp;(o=n,n={}),\"function\"==typeof o?(r.debug&amp;&amp;console.log(\"Debug: set has a callback; running async\"),process.nextTick(function(){var a;return a=r.setInternal(e,t,n),o(a[0],a[1])}),null):(r.debug&amp;&amp;console.log(\"Debug: get has no callback; running sync\"),r.setInternal(e,t,n)[1])},n.prototype.setInternal=function(t,n,o){var a,i,u;try{return null==o&amp;&amp;(o={}),null==(i=o.maxAge)&amp;&amp;(o.maxAge=r.maxAge),null==(u=o.deathTime)&amp;&amp;(o.deathTime=r.deathTime),a=new e(t,n,o),r.heap[t]=a,r.debug&amp;&amp;console.log(\"Debug: set heap[\"+t+\"] to \"+n),[null,a.data]}catch(l){return console.error(\"Unable to set memorable: \"+l),[{type:\"exception\",message:l},null]}},n.prototype.get=function(e,t){return r=this,\"function\"==typeof t?(r.debug&amp;&amp;console.log(\"Debug: get has a callback; running async\"),process.nextTick(function(){var n;return n=r.getInternal(e),t(n[0],n[1])}),null):(r.debug&amp;&amp;console.log(\"Debug: get has no callback; running sync\"),r.getInternal(e)[1])},n.prototype.getInternal=function(e){var t;return r.debug&amp;&amp;console.log(\"Debug: getting key \"+e+\" from heap\"),t=r.heap[e],t===void 0?(r.debug&amp;&amp;console.log(\"Debug: not found\"),[{type:\"notfound\",message:\"Key \"+e+\" not found in heap.\"},null]):t.isGood?(r.debug&amp;&amp;console.log(\"Debug: found it!\"),[null,t.data]):(r.debug&amp;&amp;console.log(\"Debug: expired or invalid\"),r.destroy(e),[{type:\"notvalid\",message:\"Key \"+e+\" expired or invalid.\"},null])},n.prototype.getOrSet=function(e,t,n,o){var a;if(r=this,\"function\"==typeof n&amp;&amp;(o=n,n={}),\"function\"!=typeof o){if(r.debug&amp;&amp;console.log(\"Debug: getOrSet; getting sync\"),a=r.getInternal(e),a[0]){if(r.debug&amp;&amp;console.log(\"Debug: getOrSet; no valid key; setting\"),n.async)throw\"Cannot call getOrSet async without a callback!\";return r.setInternal(e,t(),n)}if(r.heap[e].isNearDeath()){if(r.debug&amp;&amp;console.log(\"Debug: getOrSet; key is near death; will set after get\"),n.async)throw\"Cannot call getOrSet async without a callback!\";process.nextTick(function(){return r.set(e,t(e,n))})}return a[1]}return r.debug&amp;&amp;console.log(\"Debug: getOrSet; getting async\"),r.get(e,function(a,i){return a?(r.debug&amp;&amp;console.log(\"Debug: getOrSet; key invalid, setting back\"),n.async?(r.debug&amp;&amp;console.log(\"Debug: getOrSet; setback is async\"),t(e,function(t){return r.set(e,t,n,o)})):(r.debug&amp;&amp;console.log(\"Debug: getOrSet; setback is sync\"),r.set(e,t(e),n,o))):(r.debug&amp;&amp;console.log(\"Debug: getOrSet; key exists, calling back\"),o(null,i),r.heap[e].isNearDeath()?(r.debug&amp;&amp;console.log(\"Debug: getOrSet; key is near death; will set after get\"),n.async?process.nextTick(function(){return t(e,function(t){return r.set(e,t,n)})}):process.nextTick(function(){return r.set(e,t(e,n))})):void 0)}),r.get(e,function(a,i){var u;return a?\"notfound\"===a.type||\"invalid\"===a.type?(u=t(),r.set(e,u,n,o)):o(a):o(null,i)})},n.prototype.destroy=function(e,t){return\"function\"==typeof t?process.nextTick(function(){return r.heap[e]===void 0?(r.debug&amp;&amp;console.log(\"Debug: destroy async - key does not exist: \"+e),t(!1)):(r.debug&amp;&amp;console.log(\"Debug: destroy async - destroying key: \"+e),r.heap[e].destroy(),t(delete r.heap[e]))}):r.heap[e]===void 0?(r.debug&amp;&amp;console.log(\"Debug: destroy sync - key does not exist: \"+e),!1):(r.debug&amp;&amp;console.log(\"Debug: destroy sync - destroying key: \"+e),r.heap[e].emit(\"destroy\"),delete r.heap[e])},n.prototype.prune=function(){var e,t,o,a,i,u,l,s,c,g,p,d,y,f,m,h;r.emit(\"pre-prune\"),clearTimeout(r.timer),u=[],l=0,m=r.heap;for(t in m)o=m[t],o.isGood()||u.push(t);for(c=0,d=u.length;d&gt;c;c++)t=u[c],l++,r.destroy(t);if(0!==r.maxCount&amp;&amp;(e=Object.keys(r.heap).length,e&gt;r.maxCount))for(a=e-r.maxCount,u=Object.keys(r.heap).slice(0,a),g=0,y=u.length;y&gt;g;g++)t=u[g],l++,r.destroy(t);if(0!==r.maxSize&amp;&amp;(s=r.calculateSize(),s&gt;r.maxSize)){i=s-r.maxSize,u=[],h=r.heap;for(t in h)if(o=h[t],u.push(t),i-=o.size,0&gt;=i)break;for(p=0,f=u.length;f&gt;p;p++)t=u[p],l++,r.destroy(t)}return r.timer=setTimeout(function(){return n.prototype.prune.call(r)},1e3*r.pruneTime),r.emit(\"prune\"),l},n.prototype.calculateSize=function(){var e,t,n,o;n=0,o=r.heap;for(e in o)t=o[e],n+=t.size;return n},n.prototype.isHealthy=function(e){var t;return t=r.heap[e],t?t.isGood()&amp;&amp;!t.isNearDeath():!1},n}(require(\"events\").EventEmitter),e=function(e){function t(e,t,o){var r,a;if(n=this,e===void 0)throw\"Memorable missing key element\";if(t===void 0)throw\"Memorable missing data element\";null==o&amp;&amp;(o={}),null==(r=o.maxAge)&amp;&amp;(o.maxAge=0),null==(a=o.deathTime)&amp;&amp;(o.deathTime=0),n.key=e,n.data=t,0!==o.maxAge&amp;&amp;(n.expires=Date.now()+1e3*o.maxAge),n.deathTime=o.deathTime,n.size=n.calculateSize()}var n;return o(t,e),t.prototype.key=\"\",t.prototype.data={},t.prototype.invalid=!1,t.prototype.size=0,t.prototype.expires=0,t.prototype.deathTime=0,n=t,t.prototype.isGood=function(){return 0!==n.expires&amp;&amp;Date.now()&gt;n.expires&amp;&amp;n.invalidate(),!n.invalid},t.prototype.isNearDeath=function(){return Date.now()&gt;n.expires-1e3*n.deathTime},t.prototype.invalidate=function(){return n.invalid=!0,n.emit(\"invalidate\")},t.prototype.calculateSize=function(){var e,t,o,r,a,i,u,l;for(o=[],i=[n.data],e=0,r=null,a=function(e){return e.__c||!1},t=function(e){return e.__c=!0},u=function(e){return delete e.__c};i.length;)l=i.pop(),function(n){var r,l;if(\"string\"==typeof n)return e+=2*n.length;if(\"boolean\"==typeof n)return e+=4;if(\"number\"==typeof n)return e+=8;if(\"object\"==typeof n&amp;&amp;!a(n)){o.push(function(){return u(n)});for(r in n)l=n[r],n.hasOwnProperty(r)&amp;&amp;i.push(l);return t(n)}}(l);for(;r=o.pop();)r.call();return e},t}(require(\"events\").EventEmitter),module.exports=t}).call(this);"];
